\section{Regelansätze}
  
\subsection{PID-Regelungsansatz}

Unser erster Ansatz, das Fahrzeug autonom fahren zu lassen basierte auf einem PID-Regler. Dieses Verfahren lässt sich in 2 große Schritte aufteilen.

\subparagraph{Bildverarbeitung}

Für die Bildverarbeitung wird das Umfeld durch die Farbkamera der Kinect aufgenommen und in den HSV-Farbraum konvertiert. Zum Erkennen der Fahrbahnbegrenzung wird das Bild entsprechend nach grünen Punkten durchsucht und gefiltert. 
Um das entstandene Rauschen zu reduzieren wird zusätzlich noch ein Medianfilter verwendet.
Das entstandene Bild wird in einem 2D-Array gespeichert, wobei die linke untere Ecke als Ursprung verwendet wird.

Für einen Spurwechsel ist das Bild der Kinect besonders in Kurven zu schmal, daher wird hier die mittlere Fahrbahnmarkierung genutzt. Hier wird das Bild nach rosafarbenen Punkten gefiltert. Da die mittlere Linie jedoch nicht durchgängig verläuft wird durch das Verfahren der Linearisierung digital eine durchgängige Markierung erzeugt.
Zuerst wird der unterste weiße Punkt erfasst und in p\textsubscript{0} abgespeichert.
\begin{align}
\label{eq:quer}	
\mathbf{p\textsubscript{0}}
\begin{pmatrix} {x\textsubscript{0}} & {y\textsubscript{0}}\end{pmatrix}
\end{align}

Jeder weitere weiße Punkt wird dann in p{\textsubscript{i}} gesichert.
\begin{align}
\label{eq:quer}	
\mathbf{p\textsubscript{i}}
\begin{pmatrix} {x\textsubscript{i}} & {y\textsubscript{i}}\end{pmatrix}
\end{align}

Durch die erkannten Punkte kann die Steigung k\textsubscript{i} errechnet werden.

\begin{align}
\label{eq:quer}	
\mathbf{k_i}
= \frac{\mathbf{y_i} - \mathbf{y_0}}{\mathbf{x_i}-\mathbf{x_0}}
\end{align}

Zuletzt wird daraus dann der Durschnittswert aller Steigungen S berechnet.

\begin{align}
\label{eq:quer}	
\mathbf{S}
= \frac{\mathbf{1}}{\mathbf{m}}\sum \mathbf{k_i}
\end{align}

Mit dieser Steigung werden die Lücken zwischen den erkannten Linienabschnitten ergänzt.

\subparagraph{Regelkreis}
  Für die Steuerung des Fahrzeugs wird die Differenz zwischen der aktuellen Stellung des Fahrzeugs und der geplanten Richtung verwendet. Relativ zu dieser Abweichung wird das Steering-Level entsprechend gesetzt.
  
  Um die Analyse der Geschwindigkeit zu vereinfachen, wird hierzu lediglich eine Dimension betrachtet, da die anderen Geschwindigkeitsvektoren dazu relativ klein und vernachlässigbar sind. Die Orientierung der Geschwindigkeit wird als B(t) ausgegeben.
  
  \begin{align}
  \label{eq:quer}	
  \mathbf{B(t)} =
  \begin{pmatrix} {x_b(t)} & {y_b(t)}\end{pmatrix}
  \end{align}
  
  Als Sollwert A(t) wird die aufgenommene und bearbeitete Strecke verwendet. Die Abweichung zwischen Soll- und Ist-Wert wird aufintegriert und als Eingabewert e(t) für die PID-Regelung verwendet, wodurch das passende Steering-Level u(t) gesetzt werden kann.
  \begin{align}
  \label{eq:quer}	
  \mathbf{A(t)} =
  \begin{pmatrix} {x_a(t)} & {y_a(t)}\end{pmatrix}
  \end{align}
  \begin{align}
  \label{eq:quer}	
  \mathbf{e(t)}
  = \sum_{\mathbf{y=0}}^{\mathbf{n}} \mid \mathbf{x_A-x_B} \mid
  \end{align}
  \begin{align}
  \label{eq:quer}	
  \mathbf{u(t)=K_p*e(t)+K_D*} \dot{\mathbf{e}}\mathbf{(t)}
  \end{align}   
  \\
  
  \begin{figure}[ht]
  	\centering
  	\includegraphics[width=0.9\textwidth]{pics/PID-Regelung.png}
  	\caption{PID-Regeldifferenz, Solllinie(rot), Lanepixel(blau), Abweichungen(schwarz)}
  	\label{fig:quadraticorig}
  \end{figure}


\clearpage
\subsection{Modellprädiktiver Regelungansatz}
Ein zweiter experimenteller Ansatz, der im Rahmen des Projektseminars verfolgt wurde, ist die sogenannte lineare modellprädiktive Regelung. Bei dieser wird anhand eines linearen, diskretisierten Fahrzeugmodells über ein quadratisches Optimierungsproblem eine Lösung für die optimalen Lenkwinkel berechnet. Diese sind optimal in dem Sinne, dass eine Linearkombination der mittleren quadratischen Abweichungen des prädiktierten Systemzustands und Stellgröße zu einer vorgegebenen Solltrajektorie über einen endlichen Zeithorizont hinaus minimiert wird.

Ein großer Vorteil dieses Verfahrens ist, dass es automatisch Stellgrößenbeschränkungen beachtet und es somit nicht zu Prädiktionsfehlern durch unbeschränkte Stellgrößen kommt. Durch die Methode erhält man zugleich den gesamten Stellgrößenverlauf für den eingestellten Zeithorizont, sodass es außerdem möglich ist, über längere Zeit ohne Neuberechnung an einer Solltrajektorie entlang zu fahren, vorausgesetzt das linearisierte Modell ist für die gegebene Zustandstrajektorie ausreichend genau. 

Zunächst bringen wir das Problem in die Form, die für die lineare modellprädiktive Regelung benötigt wird. Dabei orientieren wir uns an \cite{hovd2004brief} sowie an Vorarbeiten von Herrn Eric Lenz am FG RTM. Wir gehen aus vom Querführungsmodell in Gleichung \ref{eq:quer} von Herrn Eric Lenz am FG RTM, welches bereits das Ackermannmodell auf eine Raumdimension reduziert:
\begin{align}
	\label{eq:quer}	
	\begin{pmatrix} \dot{y} \\ \dot{\varphi_K} \end{pmatrix}
	= 
	\begin{pmatrix} 0 & v \\ 0 & 0 \end{pmatrix}
	\begin{pmatrix} {y} \\ {\varphi_K} \end{pmatrix}
	+ 
	\begin{pmatrix} v\cdot \frac{l_H}{l} \\ \frac{v}{l} \end{pmatrix}
	\varphi_L^*
	= \mathbf{Ax + Bu}
\end{align}
Das Modell wird per Hand mit der Abtastperiode $T$ diskretisiert zu
\begin{align}
	\mathbf{A_d} = e^{\mathbf{A}T} = 
	\begin{pmatrix} 1 & vT \\ 0 & 1 \end{pmatrix} \\
	\mathbf{B_d} = \int_0^T e^{\mathbf{A}\tau} \mathbf{B} d\tau = 
	\begin{pmatrix} \frac{vTl_h}{l} + \frac{v^2T^2}{2l} \\ \frac{vT}{l} \end{pmatrix} \\	
	\begin{pmatrix} y(k+1) \\ \varphi_K(k+1) \end{pmatrix}
	= 
	\begin{pmatrix} 1 & vT \\ 0 & 1 \end{pmatrix} 
	\begin{pmatrix} y(k) \\ \varphi_K(k) \end{pmatrix}
	+ 
	\begin{pmatrix} \frac{vTl_h}{l} + \frac{v^2T^2}{2l} \\ \frac{vT}{l} \end{pmatrix} 
	\varphi_L^*(k)
	\label{eq:diskret}	
\end{align}
Es sei nun eine Trajektorie nach den Gleichungen \ref{eq:traj1}, \ref{eq:traj2} gegeben, deren Erzeugung wir an späterer Stelle erläutern.
\begin{align}	
	\label{eq:traj1}
	x_{ref} &= 
	\begin{pmatrix} x_{ref,1} & x_{ref,2} & \hdots & x_{ref,n-1} & x_{ref,n} \end{pmatrix}^T \\ 
	\label{eq:traj2}
	u_{ref} &= 
	\begin{pmatrix} u_{ref,0} & u_{ref,1} & \hdots & u_{ref,n-2} & u_{ref,n-1} \end{pmatrix}^T 
\end{align}
Dann definieren wir
\begin{align}
	\hat{Q} &= 100 \cdot diag(1,0.001,\cdots,1,0.001) ;\quad
	\hat{P} = \mathbf{I}_{n,n} ;\quad
	-U_{min} = U_{max} = 21^o \nonumber\\
	x_0 &= 
	\begin{pmatrix} y(k) \\ 0 \end{pmatrix} ;\quad
	A = 
	\begin{pmatrix} 1 & vT \\ 0 & 1 \end{pmatrix} ;\quad
	B = 
	\begin{pmatrix} \frac{vTl_h}{l} + \frac{v^2T^2}{2l} \\ \frac{vT}{l} \end{pmatrix} \nonumber\\
	\chi_0 &= 
	\begin{pmatrix} A \\ A^2 \\ \vdots \\ A^{n-1} \\ A^n \end{pmatrix}
	x_0
	+
	\begin{pmatrix} 
		B & 0 & \hdots & 0 & 0 \\ 
		AB & B & \ddots & \vdots & \vdots \\ 
		\vdots & \vdots & \ddots & 0 & 0 \\ 
		A^{n-2}B & A^{n-3}B & \hdots & B & 0 \\ 
		A^{n-1}B & A^{n-2}B & \hdots & AB & B
	\end{pmatrix}
	u_{ref} - x_{ref} 
\end{align}
Wir möchten nun die quadratischen Zustandsabweichungen und Stellgrößen über den endlichen Zeithorizont $n$ unter Beachtung der Stellgrößenbeschränkung und Systemdynamik optimieren.
\begin{align*}
	\min_v f(x,u) =
	&\sum_{t=0}^{n-1} \{(x_i - x_{ref,i})^TQ(x_i - x_{ref,i})\\
	& + (u_i - u_{ref,i})^TP(u_i - u_{ref,i})\}\\
	& + (x_n - x_{ref,n})^TQ(x_n - x_{ref,n})
\end{align*}
unter den Nebenbedingungen
\begin{align*}
x_0 
& = gegeben\\
x_{i}
& = Ax_{i-1} + Bu_{i-1} \quad \text{for} \quad 1 \leq i \leq n\\
U_L
& \leq u_i \leq U_U \quad \text{for} \quad 0 \leq i \leq n-1
\end{align*}
Wir können dann das folgende äquivalente quadratische Optimierungsproblem für $n$ Zeitschritte definieren \cite{hovd2004brief}, welches die quadratischen Positionsabweichungen über $n$ Zeitschritte vorwärts minimiert.
\begin{align}
	\min_v f(v) 
	&= 0.5v^T\tilde{H}v + c^Tv \\
	&= (x_0 - x_{ref,0})^TQ(x_0 - x_{ref,0}) + \chi_0^T\hat{Q}\chi_0 + 2\chi_0^T\hat{Q}\chi_v + \chi_v^T\hat{Q}\chi_v + v^T\hat{P}v 
\end{align}
mit den Stellgrößen-Nebenbedingungen
\begin{align}
	\mathbf{I}_{n,n}v &\geq \begin{pmatrix} U_{min} \\ \vdots \\ U_{min} \end{pmatrix} - u_{ref} \\
	-\mathbf{I}_{n,n}v &\geq -\begin{pmatrix} U_{max} \\ \vdots \\ U_{max} \end{pmatrix} + u_{ref}
\end{align}
Da wir keine Zustandsgrößenbeschränkung vorsehen, benötigen wir die restlichen Nebenbedingungen aus \cite{hovd2004brief} nicht. Dieses Optimierungsproblem wird für die gegebene Trajektorie on-line auf dem Fahrzeug gelöst, und der folgende optimale Stellgrößenverlauf wird abgespielt:
\begin{align}
	\varphi_{L,i} = \arctan(\varphi_{L,i}^*) = \arctan(u_i) = \arctan(v_i + u_{ref,i})
\end{align} 
Die Konvergenz, Optimalität und numerische Stabilität der Lösung des Optimierungsproblems der linearen modellprädiktiven Regelung ist hierbei durch die Verwendung von Methoden aus der quadratischen Programmierung, z.B. hier \cite{goldfarb1983numerically}, sichergestellt.

Wir haben hier die Gewichtungsmatrizen $\hat{Q}, \hat{P}$ so gesetzt, dass näherungsweise lediglich die Positionsabweichung zur Solltrajektorie minimiert werden soll. Dies erlaubt es uns daher, als Solltrajektorie den Sollstellgrößenverlauf zu ignorieren und eine beliebige Sollwinkeltrajektorie vorzugeben, da Inkonsistenzen mit dem Sollzustandsverlauf kaum ins Gewicht fallen:
\begin{align}	
u_{ref} &= 
\begin{pmatrix} 0 & 0 & \hdots & 0 & 0 \end{pmatrix}^T 
\end{align}
Als nächstes wird die Beschaffung der Sollzustandstrajektorie erläutert. Dazu bedienen wir uns der Kamera, dessen Farbdaten zunächst mithilfe einer inversen Perspektiventransformation (IPM) auf ein Birdeye-View gebracht werden. Beispielhaft ist ein bearbeitetes, transformiertes Bild in Abbildung \ref{fig:quadratic} zu sehen.

Das Bild wird in horizontale Streifen einer vordefinierten Breite unterteilt. Anschließend werden die Streifen nach den Fahrbahnbegrenzungsfarben gefiltert und Spaltenhistogramme gebildet. Die Histogrammmaxima am nächsten zur Mitte des Bildes mit einem vordefinierten Mindestabstand werden selektiert. In diesem Fall also bis zu zwei Seitenstreifenpunkte und bis zu ein Mittellinienpunkt. Diese sind in Abbildung \ref{fig:quadraticorig} als schwarze Kreise eingezeichnet.

Anschließend werden diese Punkte verwendet, um sinnvolle Wegpunkte zu definieren. Diese sind in der Abbildung \ref{fig:quadraticorig} als grüne Kreise eingezeichnet. Wegpunkte werden priorisiert zwischen einen Mittellinienpunkt und den Seitenstreifenpunkt der entsprechenden Fahrbahnseite gelegt. Falls das nicht möglich ist, z.B. weil einer der Punkte nicht existiert, legen wir ihn $\frac{1}{4}$ oder $\frac{3}{4}$ zwischen die Seitenstreifenpunkte je nach Fahrbahnseite. Falls auch das nicht möglich ist, können zusätzliche Punkte aus den bereits existierenden inferiert werden, falls mindestens ein Seitenstreifenpunkt existiert.

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.9\textwidth]{pics/windowedorig.png}
	\caption{Bearbeitetes, rücktransformiertes Bild mit quadratischer Trajektorie. Sichtbar sind Wegpunkte (grüne Kreise), die Solltrajektorie (blaue Linie), die prädiktierte Trajektorie (rote Punkte) und Lanepunkte (schwarze Kreise)}
	\label{fig:quadraticorig}
\end{figure}

Mithilfe dieser Wegpunkte kann man nun eine Trajektorie $x_{ref}$ erzeugen.In Abbildung \ref{fig:quadraticorig} ist die blaue Linie eine quadratische Trajektorie, die an die grünen Wegpunkte gefittet wird. Die Trajektorie scheint zunächst gut an die Fahrbahn angepasst zu sein. Man erkennt, dass die Solltrajektorie nicht einhaltbar ist, da die Querabweichung sich aus dem Unterschied zwischen polynomiell extrapolierter Solltrajektorie und Roboterposition zusammensetzt und nicht bei null beginnt. Dies ist kein Problem, da lediglich der quadratische Fehler über die nächsten Zeitschritte minimiert wird. 

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.9\textwidth]{pics/windowed.png}
	\caption{Transformierte und um Roboterposition erweiterte Version von Abbildung \ref{fig:quadraticorig}.}
	\label{fig:quadratic}
\end{figure}

Ein Problem lässt sich in Abbildung \ref{fig:quadratic} jedoch feststellen: Die Trajektorien sind aufgrund der polynomiellen Extrapolation nicht stationär und sehr variant. Zusätzlich kommt hinzu, dass die Regressionsmethode nicht rotationsinvariant ist, denn eine Rotation der Wegpunkte führt aufgrund der vertikalen Polynomausrichtung zu einer völlig anderen Trajektorie. Diese Umstände führen dazu, dass die Regelung versagt.

Eine einfache Lösung ist es, nicht zu interpolieren, sondern wie in Abbildung \ref{fig:direct} zu sehen eine direkte lineare Trajektorie zum nächstliegenden Wegpunkt zu setzen. Dadurch wird die Trajektorie deutlich stationärer und robuster, sodass die Regelung wie erwartet funktioniert. Dasselbe Problem hat man jedoch im begrenzten Maße auch für die direkte lineare Trajektorie. Selbst wenn man auf Extrapolation verzichtet und ausreichend Mittelung verwendet, ist der unterste Bildpunkt aufgrund der auftretenden Rotation des gegenüber der Roboterposition orthogonal ausgerichteten Bildes auch für gerade Fahrstrecken variant, sobald eine Abweichung auftritt. Zusätzlich kommt es durch die Diskretisierung bei großen Zeitschritten zu Überschwingen im kontinuierlichen physikalischen System trotz Einhaltung der Zustandssollwerte im diskreten Modell.

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.9\textwidth]{pics/windoweddirect.png}
	\caption{Bearbeitetes, untransformiertes Bild mit quadratischer Trajektorie. Sichtbar sind Wegpunkte (grüne Kreise), die Solltrajektorie (blaue Linie), die prädiktierte Trajektorie (rote Punkte), Lanepunkte (schwarze Kreise) und die Roboterposition relativ zum Bild (Anfangspunkt der prädiktierten Trajektorie, großer blauer Kreis)}
	\label{fig:direct}
\end{figure}

Mit dieser Bildtrajektorie und den Bildtransformationsparametern lassen sich dann diskrete Trajektoriensollwerte $x_{ref,i}$ erzeugen, indem das kinematische Querführungsmodell angenommen wird: Für jeden Trajektorienzeitschritt wird eine konstante Vorwärtsbewegung abhängig von der Geschwindigkeit ausgeführt, um den nächsten Positionssollwert zu ermitteln.

Das größte Problem ist das nicht ausreichend genaue Modell. der MPC-Ansatz erlaubt noch weitere Verbesserungen, um besseres Regelverhalten zu erreichen und insbesondere hohe Geschwindigkeiten ausreichend genau zu regeln. Darauf wird in diesem Projektseminar aber aufgrund der abweichenden Zielsetzung verzichtet.

Es bietet sich zukünftig an, das Fahrzeugmodell durch ein nichtlineares Modell zu ersetzen und allgemeinere Optimierer zu verwenden. Damit landet man bei der nichtlinearen modelprädiktiven Regelung (NMPC), z.B. \cite{allgower2012nonlinear}, bei der ein anderer Modellansatz verfolgt werden muss, da das Querabweichungsmodell eine Linearisierung ist.

Weiter kann man das Modell durch ein genaueres Modell ersetzen. Erstens bietet es sich an, ein genaueres Modell als das Ackermann-Modell zu verwenden, um auch bei hohen Fahrgeschwindigkeiten ein ausreichend genaues Dynamikmodell zu erhalten. Zweitens kann man auch Modelle für die Servolenkung berücksichtigen, da diese nicht unendlich schnell einen Lenkwinkel einstellen kann.

Schließlich könnte man auch die Trajektoriengenerierung überarbeiten. Eine naheliegende Wahl, um auch mit Bildraten von unter 1 Hz auszukommen, ist die Verwendung der direkten Trajektorie bis zum ersten Wegpunkt und darauffolgende Verwendung der quadratischen Trajektorie. Da die quadratische Trajektorie in diesem Fall nicht mehr extrapoliert, bietet diese eine hervorragende Trajektorienform für eine Regelung mit wenigen Bildern. 

%\begin{figure}
%	\centering
%	\begin{tikzpicture}
%	\begin{axis}[ 
%	xtick={0, 200, ..., 1000},
%	ytick={0, 1, ..., 2},
%	ylabel near ticks,
%	xlabel near ticks,
%	xmin=0,
%	xmax=1000,
%	ymin=0,
%	ymax=2,
%	xlabel=$u_{m}$,
%	ylabel={$v(u_{m})$},
%	scaled y ticks = false,
%	yticklabel={$\tick \frac{m}{s}$},
%	]
%	\addplot [mark=none,domain=0:1000] {max(0, 0.00225 * (x - 100))};
%	\end{axis}
%	\end{tikzpicture}
%	\caption{Geschwindigkeitskennlinie $v(u_{m}) = max({0}{\frac{mm}{s}}, {2.25}{\frac{mm}{s}} * (u_{m} - 100))$}
%\end{figure}
%
%\begin{figure}
%	\centering
%	\begin{tikzpicture}
%	\begin{axis}[ 
%	xtick={-1000, -600, ..., 1000},
%	ytick={-25, -15, ..., 25},
%	ylabel near ticks,
%	xlabel near ticks,
%	xmin=-1000,
%	xmax=1000,
%	ymin=-25,
%	ymax=25,
%	xlabel=$u_{l}$,
%	ylabel={$\varphi(u_{l})$},
%	yticklabel={$\tick ^o$}
%	] 
%	\addplot [mark=none,domain=-1000:1000] {21 * x / 1000};
%	\end{axis}
%	\end{tikzpicture}
%	\caption{Lenkwinkelkennlinie $\varphi(u_{l}) = \frac{21^o}{1000} * u_{l} ))$}
%\end{figure}